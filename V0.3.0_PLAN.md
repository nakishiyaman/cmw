# CMW v0.3.0 開発計画

**策定日**: 2025-10-16
**対象バージョン**: v0.2.0 → v0.3.0
**テーマ**: Phase 8 - Claude Code統合最適化
**推定時間**: 13-18時間（約2-3日）

---

## 🎯 v0.3.0の目標

**メインテーマ**: **Claude Code統合の最適化とタスク可視化の強化**

### 成功基準
1. ✅ タスク依存関係がビジュアル化される
2. ✅ Claude Codeへのプロンプトが最適化される
3. ✅ Pythonコードの依存関係が自動解析される
4. ✅ 問題修正が対話的に行える
5. ✅ Claude Codeの出力から自動的にタスク完了を検出

---

## 📊 v0.2.0の成果（振り返り）

### 実装完了した機能
- **Phase 0-7**: 基盤構築から進捗UI完成まで
- **v0.2.0新機能**:
  - 循環依存の自動修正（DependencyValidator）
  - 非タスク項目の自動除外（TaskFilter）
  - タスク検証コマンド（`cmw task validate`）
  - Git連携による進捗自動更新（`cmw sync --from-git`）

### 統計
- **モジュール数**: 16個
- **コード行数**: 4,495行
- **テスト数**: 153個（全てPASS）
- **検証プロジェクト**: blog-api、todo-api

### 残された課題
1. タスク依存関係の可視化が不足
2. Claude Code統合のプロンプトが最適化されていない
3. Pythonコードの依存関係が手動推論のみ
4. 問題修正が非対話的
5. タスク完了の報告が手動

---

## 🚀 v0.3.0実装スコープ

### Phase 8: Claude Code統合最適化（13-18時間）

#### Phase 8.1: タスクグラフ可視化 ⭐⭐⭐⭐⭐
**推定時間**: 2-3時間
**優先度**: 最高

##### 実装内容

**新規ファイル**: `src/cmw/graph_visualizer.py`

```python
"""
Graph Visualizer - タスク依存関係の可視化
"""
from typing import List, Optional
import networkx as nx
from rich.console import Console
from rich.tree import Tree
from pathlib import Path

class GraphVisualizer:
    """タスクグラフの可視化機能"""

    def __init__(self, tasks: List[Task]):
        self.tasks = tasks
        self.graph = self._build_graph()

    def _build_graph(self) -> nx.DiGraph:
        """依存関係グラフを構築"""
        G = nx.DiGraph()
        for task in self.tasks:
            G.add_node(task.id, **{
                'title': task.title,
                'status': task.status.value,
                'priority': task.priority.value
            })
            for dep_id in task.dependencies:
                G.add_edge(task.id, dep_id)
        return G

    def render_ascii(self) -> str:
        """ASCII形式でグラフを描画"""
        console = Console()
        tree = Tree("📋 タスク依存関係グラフ")

        # ルートタスク（依存元がないタスク）を探す
        root_tasks = [t for t in self.tasks if not t.dependencies]

        for root_task in root_tasks:
            self._add_tree_node(tree, root_task)

        return tree

    def _add_tree_node(self, parent_tree, task: Task):
        """ツリーノードを追加（再帰）"""
        status_icon = {
            'pending': '⏳',
            'in_progress': '🔄',
            'completed': '✅',
            'failed': '❌'
        }

        label = f"{status_icon.get(task.status.value, '?')} {task.id}: {task.title}"
        node = parent_tree.add(label)

        # 依存先タスクを追加
        dependent_tasks = [t for t in self.tasks if task.id in t.dependencies]
        for dep_task in dependent_tasks:
            self._add_tree_node(node, dep_task)

    def render_mermaid(self) -> str:
        """Mermaid形式でグラフを出力"""
        lines = ["```mermaid", "graph TD"]

        for task in self.tasks:
            # ノード定義
            status_color = {
                'pending': '[[" + task.id + "]]',
                'in_progress': '(" + task.id + ")',
                'completed': '[(" + task.id + ")]',
                'failed': '[x' + task.id + 'x]'
            }
            lines.append(f"  {task.id}[\"{task.id}: {task.title}\"]")

            # エッジ定義
            for dep_id in task.dependencies:
                lines.append(f"  {task.id} --> {dep_id}")

        lines.append("```")
        return "\n".join(lines)

    def export_graphviz(self, output_path: Path):
        """Graphviz形式でエクスポート"""
        try:
            from networkx.drawing.nx_agraph import to_agraph

            A = to_agraph(self.graph)
            A.layout('dot')
            A.draw(output_path)
            return True
        except ImportError:
            return False

    def get_critical_path(self) -> List[str]:
        """クリティカルパスを計算"""
        try:
            path = nx.dag_longest_path(self.graph)
            return path
        except nx.NetworkXError:
            return []

    def get_parallel_groups(self) -> List[List[str]]:
        """並列実行可能なタスクグループを取得"""
        groups = []
        remaining = set(t.id for t in self.tasks if t.status == TaskStatus.PENDING)

        while remaining:
            # 依存が満たされているタスクを取得
            executable = []
            for task_id in remaining:
                task = next(t for t in self.tasks if t.id == task_id)
                deps_satisfied = all(
                    dep_id not in remaining for dep_id in task.dependencies
                )
                if deps_satisfied:
                    executable.append(task_id)

            if not executable:
                break

            groups.append(executable)
            remaining -= set(executable)

        return groups
```

##### CLIコマンド実装

**追加先**: `src/cmw/cli.py`

```python
@task.command('graph')
@click.option('--format', type=click.Choice(['ascii', 'mermaid', 'png']),
              default='ascii', help='出力形式')
@click.option('--output', type=click.Path(), help='出力ファイルパス（PNG形式の場合）')
@click.option('--show-critical-path', is_flag=True, help='クリティカルパスを表示')
@click.option('--show-parallel-groups', is_flag=True, help='並列実行グループを表示')
def graph_tasks(format: str, output: Optional[str],
                show_critical_path: bool, show_parallel_groups: bool):
    """タスク依存関係グラフを可視化"""
    from rich.console import Console
    from cmw.graph_visualizer import GraphVisualizer

    console = Console()
    coordinator = Coordinator(Path.cwd())
    tasks_list = list(coordinator.tasks.values())

    visualizer = GraphVisualizer(tasks_list)

    # グラフ描画
    if format == 'ascii':
        tree = visualizer.render_ascii()
        console.print(tree)
    elif format == 'mermaid':
        mermaid_code = visualizer.render_mermaid()
        console.print(mermaid_code)
    elif format == 'png':
        if not output:
            output = 'task_graph.png'
        success = visualizer.export_graphviz(Path(output))
        if success:
            console.print(f"[green]✅ グラフを {output} に出力しました[/green]")
        else:
            console.print("[red]❌ Graphvizがインストールされていません[/red]")
            console.print("インストール: pip install pygraphviz")

    # クリティカルパス
    if show_critical_path:
        critical_path = visualizer.get_critical_path()
        console.print("\n[bold]🎯 クリティカルパス:[/bold]")
        console.print(" → ".join(critical_path))

    # 並列実行グループ
    if show_parallel_groups:
        groups = visualizer.get_parallel_groups()
        console.print("\n[bold]⚡ 並列実行グループ:[/bold]")
        for i, group in enumerate(groups, 1):
            console.print(f"  グループ{i}: {', '.join(group)}")
```

##### テストケース

**新規ファイル**: `tests/test_graph_visualizer.py`

```python
def test_build_graph():
    """グラフ構築テスト"""
    tasks = [
        Task(id="TASK-001", dependencies=[]),
        Task(id="TASK-002", dependencies=["TASK-001"]),
        Task(id="TASK-003", dependencies=["TASK-001"]),
    ]

    visualizer = GraphVisualizer(tasks)
    assert len(visualizer.graph.nodes) == 3
    assert len(visualizer.graph.edges) == 2

def test_render_ascii():
    """ASCII描画テスト"""
    tasks = [Task(id="TASK-001", title="認証", dependencies=[])]
    visualizer = GraphVisualizer(tasks)
    tree = visualizer.render_ascii()
    assert "TASK-001" in str(tree)

def test_get_critical_path():
    """クリティカルパステスト"""
    tasks = [
        Task(id="TASK-001", dependencies=[]),
        Task(id="TASK-002", dependencies=["TASK-001"]),
        Task(id="TASK-003", dependencies=["TASK-002"]),
    ]

    visualizer = GraphVisualizer(tasks)
    critical_path = visualizer.get_critical_path()
    assert critical_path == ["TASK-003", "TASK-002", "TASK-001"]

def test_get_parallel_groups():
    """並列実行グループテスト"""
    tasks = [
        Task(id="TASK-001", dependencies=[], status=TaskStatus.COMPLETED),
        Task(id="TASK-002", dependencies=["TASK-001"], status=TaskStatus.PENDING),
        Task(id="TASK-003", dependencies=["TASK-001"], status=TaskStatus.PENDING),
    ]

    visualizer = GraphVisualizer(tasks)
    groups = visualizer.get_parallel_groups()
    assert len(groups) == 1
    assert set(groups[0]) == {"TASK-002", "TASK-003"}
```

##### 検証方法

```bash
# blog-apiで検証
cd ~/workspace/projects/blog-api

# ASCII形式で表示
cmw task graph

# クリティカルパスを表示
cmw task graph --show-critical-path

# 並列実行グループを表示
cmw task graph --show-parallel-groups

# Mermaid形式で出力
cmw task graph --format mermaid

# PNG画像出力（Graphvizインストール済みの場合）
cmw task graph --format png --output blog_api_graph.png
```

**期待される結果**:
- ✅ タスク依存関係がツリー形式で表示される
- ✅ ステータスがアイコンで表示される（⏳ 🔄 ✅ ❌）
- ✅ クリティカルパスが正しく計算される
- ✅ 並列実行可能なタスクが正しくグループ化される

---

#### Phase 8.2: プロンプトテンプレート ⭐⭐⭐⭐⭐
**推定時間**: 2-3時間
**優先度**: 最高

##### 実装内容

**新規ファイル**: `src/cmw/prompt_template.py`

```python
"""
Prompt Template - Claude Code向けプロンプト生成
"""
from typing import Optional, Dict, List
from pathlib import Path
from cmw.models import Task, TaskStatus
from cmw.coordinator import Coordinator

class PromptTemplate:
    """タスク実行用プロンプトを生成"""

    def __init__(self, project_path: Path):
        self.project_path = project_path
        self.coordinator = Coordinator(project_path)

    def generate_task_prompt(self, task: Task) -> str:
        """
        タスク実行用の最適化されたプロンプトを生成

        Args:
            task: 実行対象のタスク

        Returns:
            Claude Codeが効率的に実行できるプロンプト
        """
        sections = []

        # 1. タスク概要
        sections.append(self._build_task_overview(task))

        # 2. 実装内容
        sections.append(self._build_implementation_details(task))

        # 3. 対象ファイル
        sections.append(self._build_target_files(task))

        # 4. 依存情報
        sections.append(self._build_dependencies(task))

        # 5. 受け入れ基準
        sections.append(self._build_acceptance_criteria(task))

        # 6. コンテキスト情報
        sections.append(self._build_context(task))

        # 7. 実行手順
        sections.append(self._build_execution_steps(task))

        return "\n\n".join(filter(None, sections))

    def _build_task_overview(self, task: Task) -> str:
        """タスク概要セクション"""
        return f"""# タスク: {task.title}

**タスクID**: {task.id}
**優先度**: {task.priority.value}
**担当**: {task.assigned_to or 'backend'}
"""

    def _build_implementation_details(self, task: Task) -> str:
        """実装内容セクション"""
        if not task.description:
            return ""

        return f"""## 実装内容

{task.description}
"""

    def _build_target_files(self, task: Task) -> str:
        """対象ファイルセクション"""
        if not task.target_files:
            return ""

        files_list = "\n".join(f"- `{f}`" for f in task.target_files)
        return f"""## 対象ファイル

{files_list}
"""

    def _build_dependencies(self, task: Task) -> str:
        """依存情報セクション"""
        if not task.dependencies:
            return ""

        deps_info = []
        for dep_id in task.dependencies:
            dep_task = self.coordinator.tasks.get(dep_id)
            if dep_task:
                status_icon = {
                    TaskStatus.COMPLETED: "✅",
                    TaskStatus.IN_PROGRESS: "🔄",
                    TaskStatus.PENDING: "⏳",
                    TaskStatus.FAILED: "❌"
                }
                icon = status_icon.get(dep_task.status, "?")
                deps_info.append(f"- {icon} {dep_id}: {dep_task.title}")

        return f"""## 依存タスク（事前に完了している必要があります）

{chr(10).join(deps_info)}
"""

    def _build_acceptance_criteria(self, task: Task) -> str:
        """受け入れ基準セクション"""
        if not task.acceptance_criteria:
            return ""

        criteria_list = "\n".join(f"- [ ] {c}" for c in task.acceptance_criteria)
        return f"""## 受け入れ基準

{criteria_list}
"""

    def _build_context(self, task: Task) -> str:
        """コンテキスト情報セクション"""
        context_parts = []

        # requirements.mdのセクション参照
        if task.description and "##" in task.description:
            context_parts.append("**参照ドキュメント**: shared/docs/requirements.md")

        # API仕様参照
        api_spec_path = self.project_path / "shared" / "docs" / "api-spec.md"
        if api_spec_path.exists():
            context_parts.append("**API仕様**: shared/docs/api-spec.md")

        # 既存ファイル参照
        if task.target_files:
            existing_files = []
            for file_path in task.target_files:
                full_path = self.project_path / "shared" / "artifacts" / file_path
                if full_path.exists():
                    existing_files.append(f"  - {file_path} (既存)")

            if existing_files:
                context_parts.append("**既存ファイル**:\n" + "\n".join(existing_files))

        if not context_parts:
            return ""

        return f"""## コンテキスト情報

{chr(10).join(context_parts)}
"""

    def _build_execution_steps(self, task: Task) -> str:
        """実行手順セクション"""
        steps = [
            "1. 依存タスクが全て完了していることを確認",
            "2. 対象ファイルを作成/編集",
            "3. 受け入れ基準を満たす実装を行う",
            "4. テストを作成・実行",
            "5. 完了報告: `cmw.mark_completed(task_id, artifacts)`"
        ]

        return f"""## 実行手順

{chr(10).join(steps)}
"""

    def generate_context_prompt(self, task: Task) -> Dict[str, any]:
        """
        Claude CodeのPython APIで使用する辞書形式のコンテキスト
        """
        return {
            "task_id": task.id,
            "title": task.title,
            "description": task.description,
            "target_files": task.target_files or [],
            "dependencies": task.dependencies or [],
            "acceptance_criteria": task.acceptance_criteria or [],
            "priority": task.priority.value,
            "assigned_to": task.assigned_to or "backend",
            "status": task.status.value
        }

    def generate_completion_template(self, task: Task, artifacts: List[str]) -> str:
        """タスク完了報告用のテンプレート"""
        return f"""タスク {task.id} を完了しました。

## 成果物
{chr(10).join(f"- {a}" for a in artifacts)}

## 完了した受け入れ基準
{chr(10).join(f"- [x] {c}" for c in task.acceptance_criteria or [])}
"""
```

##### TaskProviderへの統合

**修正ファイル**: `src/cmw/task_provider.py`

```python
class TaskProvider:
    """既存クラスに追加"""

    def __init__(self, project_path: Path):
        self.project_path = project_path
        self.coordinator = Coordinator(project_path)
        self.template = PromptTemplate(project_path)  # 🆕 追加

    def get_task_prompt(self, task_id: str) -> str:
        """
        タスク実行用のプロンプトを取得

        🆕 v0.3.0新機能
        """
        task = self.coordinator.tasks.get(task_id)
        if not task:
            raise ValueError(f"Task {task_id} not found")

        return self.template.generate_task_prompt(task)

    def get_task_context_dict(self, task_id: str) -> Dict[str, any]:
        """
        タスクコンテキストを辞書形式で取得

        🆕 v0.3.0新機能
        """
        task = self.coordinator.tasks.get(task_id)
        if not task:
            raise ValueError(f"Task {task_id} not found")

        return self.template.generate_context_prompt(task)
```

##### CLIコマンド実装

**追加先**: `src/cmw/cli.py`

```python
@task.command('prompt')
@click.argument('task_id')
@click.option('--format', type=click.Choice(['markdown', 'json']),
              default='markdown', help='出力形式')
def show_task_prompt(task_id: str, format: str):
    """タスク実行用プロンプトを表示"""
    from rich.console import Console
    from rich.markdown import Markdown
    from cmw.task_provider import TaskProvider
    import json

    console = Console()
    provider = TaskProvider(Path.cwd())

    try:
        if format == 'markdown':
            prompt = provider.get_task_prompt(task_id)
            md = Markdown(prompt)
            console.print(md)
        elif format == 'json':
            context = provider.get_task_context_dict(task_id)
            console.print_json(json.dumps(context, indent=2, ensure_ascii=False))
    except ValueError as e:
        console.print(f"[red]❌ エラー: {e}[/red]")
```

##### テストケース

**新規ファイル**: `tests/test_prompt_template.py`

```python
def test_generate_task_prompt(temp_project):
    """プロンプト生成テスト"""
    task = Task(
        id="TASK-001",
        title="認証API実装",
        description="JWT認証を使用したログイン機能",
        target_files=["backend/auth.py"],
        acceptance_criteria=["POST /login実装", "JWTトークン発行"],
        priority=Priority.HIGH
    )

    template = PromptTemplate(temp_project)
    prompt = template.generate_task_prompt(task)

    assert "TASK-001" in prompt
    assert "認証API実装" in prompt
    assert "backend/auth.py" in prompt
    assert "POST /login実装" in prompt

def test_generate_context_prompt():
    """コンテキスト辞書生成テスト"""
    task = Task(id="TASK-001", title="認証")
    template = PromptTemplate(Path.cwd())
    context = template.generate_context_prompt(task)

    assert context['task_id'] == "TASK-001"
    assert context['title'] == "認証"
    assert 'target_files' in context

def test_generate_completion_template():
    """完了テンプレート生成テスト"""
    task = Task(
        id="TASK-001",
        acceptance_criteria=["テスト完了"]
    )
    template = PromptTemplate(Path.cwd())
    completion = template.generate_completion_template(
        task, ["backend/auth.py"]
    )

    assert "TASK-001" in completion
    assert "backend/auth.py" in completion
```

##### 検証方法

```bash
# プロンプト表示
cmw task prompt TASK-001

# JSON形式で表示
cmw task prompt TASK-001 --format json

# PythonからAPI使用
python3 << 'EOF'
from pathlib import Path
from cmw import TaskProvider

provider = TaskProvider(Path.cwd())

# プロンプト取得
prompt = provider.get_task_prompt("TASK-001")
print(prompt)

# コンテキスト辞書取得
context = provider.get_task_context_dict("TASK-001")
print(context)
EOF
```

**期待される結果**:
- ✅ タスク実行に必要な全情報が含まれる
- ✅ Markdown形式で読みやすい
- ✅ JSON形式でプログラムから使いやすい
- ✅ Claude Codeが効率的に実行できる構造

---

#### Phase 8.3: 依存関係の静的分析 ⭐⭐⭐⭐
**推定時間**: 4-5時間
**優先度**: 高

##### 実装内容

**新規ファイル**: `src/cmw/static_analyzer.py`

```python
"""
Static Analyzer - Pythonコードの静的解析
"""
import ast
from pathlib import Path
from typing import List, Set, Dict, Tuple
from cmw.models import Task

class StaticAnalyzer:
    """Pythonコードの静的解析機能"""

    def __init__(self, project_path: Path):
        self.project_path = project_path
        self.artifacts_path = project_path / "shared" / "artifacts"

    def analyze_file_dependencies(self, file_path: str) -> Set[str]:
        """
        ファイルの依存関係を解析

        Args:
            file_path: 解析対象ファイル（例: "backend/auth.py"）

        Returns:
            依存しているファイルのセット
        """
        full_path = self.artifacts_path / file_path

        if not full_path.exists():
            return set()

        try:
            with open(full_path, 'r', encoding='utf-8') as f:
                tree = ast.parse(f.read(), filename=str(full_path))
        except SyntaxError:
            return set()

        dependencies = set()

        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    dep = self._resolve_import(alias.name)
                    if dep:
                        dependencies.add(dep)

            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    dep = self._resolve_import(node.module)
                    if dep:
                        dependencies.add(dep)

        return dependencies

    def _resolve_import(self, module_name: str) -> Optional[str]:
        """
        インポートモジュール名をファイルパスに解決

        例:
        - "backend.models" → "backend/models.py"
        - "backend.auth" → "backend/auth.py"
        """
        # 外部ライブラリは除外
        external_modules = ['fastapi', 'sqlalchemy', 'pydantic', 'pytest']
        if any(module_name.startswith(ext) for ext in external_modules):
            return None

        # 相対インポート解決
        parts = module_name.split('.')

        # backend.models → backend/models.py
        possible_paths = [
            "/".join(parts) + ".py",
            "/".join(parts) + "/__init__.py"
        ]

        for path in possible_paths:
            full_path = self.artifacts_path / path
            if full_path.exists():
                return path

        return None

    def infer_task_dependencies(self, tasks: List[Task]) -> List[Task]:
        """
        タスク間の依存関係を静的解析で推論

        Args:
            tasks: タスクリスト

        Returns:
            依存関係が更新されたタスクリスト
        """
        task_file_map = self._build_task_file_map(tasks)

        for task in tasks:
            if not task.target_files:
                continue

            inferred_deps = set()

            # 各対象ファイルの依存を解析
            for file_path in task.target_files:
                file_deps = self.analyze_file_dependencies(file_path)

                # ファイル依存からタスク依存を推論
                for dep_file in file_deps:
                    dep_task_ids = task_file_map.get(dep_file, [])
                    inferred_deps.update(dep_task_ids)

            # 既存の依存と統合
            existing_deps = set(task.dependencies or [])
            all_deps = existing_deps | inferred_deps

            # 自己依存を除外
            all_deps.discard(task.id)

            task.dependencies = sorted(all_deps)

        return tasks

    def _build_task_file_map(self, tasks: List[Task]) -> Dict[str, List[str]]:
        """
        ファイルパス → タスクIDのマッピングを構築

        Returns:
            {"backend/models.py": ["TASK-004", "TASK-005"], ...}
        """
        file_map = {}

        for task in tasks:
            if not task.target_files:
                continue

            for file_path in task.target_files:
                if file_path not in file_map:
                    file_map[file_path] = []
                file_map[file_path].append(task.id)

        return file_map

    def analyze_function_calls(self, file_path: str) -> Set[Tuple[str, str]]:
        """
        ファイル内の関数呼び出しを解析

        Args:
            file_path: 解析対象ファイル

        Returns:
            {(モジュール名, 関数名), ...}
        """
        full_path = self.artifacts_path / file_path

        if not full_path.exists():
            return set()

        try:
            with open(full_path, 'r', encoding='utf-8') as f:
                tree = ast.parse(f.read())
        except SyntaxError:
            return set()

        calls = set()

        for node in ast.walk(tree):
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Attribute):
                    # module.function() の形式
                    if isinstance(node.func.value, ast.Name):
                        module = node.func.value.id
                        func = node.func.attr
                        calls.add((module, func))
                elif isinstance(node.func, ast.Name):
                    # function() の形式
                    func = node.func.id
                    calls.add(("", func))

        return calls

    def detect_circular_imports(self, tasks: List[Task]) -> List[List[str]]:
        """
        インポートの循環を検出

        Returns:
            循環しているファイルのリスト
        """
        import networkx as nx

        G = nx.DiGraph()

        for task in tasks:
            if not task.target_files:
                continue

            for file_path in task.target_files:
                G.add_node(file_path)
                deps = self.analyze_file_dependencies(file_path)
                for dep in deps:
                    G.add_edge(file_path, dep)

        try:
            cycles = list(nx.simple_cycles(G))
            return cycles
        except nx.NetworkXNoCycle:
            return []
```

##### RequirementsParserへの統合

**修正ファイル**: `src/cmw/requirements_parser.py`

```python
class RequirementsParser:
    """既存クラスに追加"""

    def __init__(self, project_path: Path):
        self.project_path = project_path
        self.validator = DependencyValidator()
        self.task_filter = TaskFilter()
        self.static_analyzer = StaticAnalyzer(project_path)  # 🆕 追加

    def parse(self, requirements_path: Optional[Path] = None) -> List[Task]:
        """
        requirements.mdをパースしてタスクを生成

        v0.3.0: 静的解析による依存関係推論を追加
        """
        # 既存のパース処理
        tasks = self._parse_requirements_file(requirements_path)

        # 非タスク項目をフィルタリング
        tasks, non_tasks = self.task_filter.filter_tasks(tasks)

        # 🆕 静的解析で依存関係を推論（既存ファイルがある場合のみ）
        tasks = self.static_analyzer.infer_task_dependencies(tasks)

        # 循環依存の検出と修正
        cycles = self.validator.detect_cycles(tasks)
        if cycles:
            tasks = self.validator.auto_fix_cycles(tasks, cycles, auto_apply=True)

        # 🆕 インポートの循環を検出
        import_cycles = self.static_analyzer.detect_circular_imports(tasks)
        if import_cycles:
            print(f"\n⚠️  {len(import_cycles)}件のインポート循環を検出:")
            for cycle in import_cycles:
                print(f"  {' → '.join(cycle)}")

        return tasks
```

##### テストケース

**新規ファイル**: `tests/test_static_analyzer.py`

```python
def test_analyze_file_dependencies(temp_project):
    """ファイル依存解析テスト"""
    # テスト用ファイル作成
    auth_file = temp_project / "shared" / "artifacts" / "backend" / "auth.py"
    auth_file.parent.mkdir(parents=True, exist_ok=True)
    auth_file.write_text("""
from backend.models import User
from backend.database import get_db

def authenticate_user():
    pass
""")

    analyzer = StaticAnalyzer(temp_project)
    deps = analyzer.analyze_file_dependencies("backend/auth.py")

    assert "backend/models.py" in deps
    assert "backend/database.py" in deps

def test_infer_task_dependencies():
    """タスク依存推論テスト"""
    tasks = [
        Task(id="TASK-001", target_files=["backend/auth.py"]),
        Task(id="TASK-004", target_files=["backend/models.py"]),
    ]

    # auth.py が models.py をimport している場合
    analyzer = StaticAnalyzer(temp_project)
    updated_tasks = analyzer.infer_task_dependencies(tasks)

    task_001 = next(t for t in updated_tasks if t.id == "TASK-001")
    assert "TASK-004" in task_001.dependencies

def test_detect_circular_imports(temp_project):
    """インポート循環検出テスト"""
    # a.py が b.py をimport、b.py が a.py をimport
    a_file = temp_project / "shared" / "artifacts" / "a.py"
    b_file = temp_project / "shared" / "artifacts" / "b.py"

    a_file.write_text("import b")
    b_file.write_text("import a")

    tasks = [
        Task(id="TASK-001", target_files=["a.py"]),
        Task(id="TASK-002", target_files=["b.py"]),
    ]

    analyzer = StaticAnalyzer(temp_project)
    cycles = analyzer.detect_circular_imports(tasks)

    assert len(cycles) > 0
```

##### 検証方法

```bash
# 既存プロジェクトで依存関係を再推論
cd ~/workspace/projects/todo-api

# タスクを再生成（静的解析を使用）
cmw task generate --analyze-imports

# 推論された依存関係を確認
cmw task list --show-dependencies

# インポート循環をチェック
cmw task validate --check-imports
```

**期待される結果**:
- ✅ Pythonファイルのimport文が正しく解析される
- ✅ タスク間の依存関係が自動推論される
- ✅ インポート循環が検出される
- ✅ 手動での依存関係設定が不要になる

---

#### Phase 8.4: インタラクティブな修正UI ⭐⭐⭐
**推定時間**: 2-3時間
**優先度**: 中

##### 実装内容

**新規ファイル**: `src/cmw/interactive_fixer.py`

```python
"""
Interactive Fixer - 対話的な問題修正UI
"""
from typing import List, Optional
from rich.console import Console
from rich.prompt import Prompt, Confirm
from rich.table import Table
from cmw.models import Task
from cmw.dependency_validator import DependencyValidator

class InteractiveFixer:
    """対話的な問題修正機能"""

    def __init__(self):
        self.console = Console()
        self.validator = DependencyValidator()

    def fix_cycles_interactively(self, tasks: List[Task], cycles: List[List[str]]) -> List[Task]:
        """
        循環依存を対話的に修正

        Args:
            tasks: タスクリスト
            cycles: 検出された循環依存

        Returns:
            修正後のタスクリスト
        """
        self.console.print(f"\n[bold yellow]⚠️  {len(cycles)}件の循環依存を検出しました[/bold yellow]")

        for i, cycle in enumerate(cycles, 1):
            self.console.print(f"\n[bold]循環 {i}/{len(cycles)}:[/bold]")
            self.console.print(f"  {' ↔ '.join(cycle)}")

            # 修正提案を取得
            suggestions = self.validator.suggest_fixes([cycle], tasks)[0]['suggestions']

            if not suggestions:
                self.console.print("[red]  自動修正案が見つかりません[/red]")
                continue

            # 修正案を表示
            table = Table(title="修正案")
            table.add_column("番号", style="cyan")
            table.add_column("削除する依存", style="yellow")
            table.add_column("理由", style="green")
            table.add_column("信頼度", style="magenta")

            for j, suggestion in enumerate(suggestions, 1):
                table.add_row(
                    str(j),
                    f"{suggestion['from_task']} → {suggestion['to_task']}",
                    suggestion['reason'],
                    f"{suggestion['confidence']:.0%}"
                )

            self.console.print(table)

            # ユーザーに選択を求める
            choice = Prompt.ask(
                "どの修正案を適用しますか？",
                choices=[str(j) for j in range(1, len(suggestions) + 1)] + ["s", "c"],
                default="1"
            )

            if choice == "s":
                # スキップ
                self.console.print("[yellow]この循環をスキップしました[/yellow]")
                continue
            elif choice == "c":
                # キャンセル
                self.console.print("[red]修正をキャンセルしました[/red]")
                return tasks
            else:
                # 選択した修正を適用
                selected = suggestions[int(choice) - 1]
                tasks = self._apply_fix(tasks, selected)
                self.console.print(f"[green]✅ 修正を適用しました[/green]")

        return tasks

    def _apply_fix(self, tasks: List[Task], fix: dict) -> List[Task]:
        """修正を適用"""
        task_map = {t.id: t for t in tasks}
        from_task = task_map[fix['from_task']]
        to_task_id = fix['to_task']

        if to_task_id in from_task.dependencies:
            from_task.dependencies.remove(to_task_id)

        return tasks

    def select_tasks_interactively(self, tasks: List[Task],
                                   prompt_text: str = "タスクを選択してください") -> List[Task]:
        """
        タスクを対話的に選択

        Args:
            tasks: 選択肢となるタスクリスト
            prompt_text: プロンプトテキスト

        Returns:
            選択されたタスクリスト
        """
        table = Table(title="タスク一覧")
        table.add_column("番号", style="cyan")
        table.add_column("ID", style="yellow")
        table.add_column("タイトル", style="green")
        table.add_column("優先度", style="magenta")

        for i, task in enumerate(tasks, 1):
            table.add_row(
                str(i),
                task.id,
                task.title,
                task.priority.value
            )

        self.console.print(table)

        choices = Prompt.ask(
            f"{prompt_text} (カンマ区切りで複数選択可、allで全て選択)",
            default="all"
        )

        if choices == "all":
            return tasks

        selected_indices = [int(c.strip()) - 1 for c in choices.split(',')]
        return [tasks[i] for i in selected_indices if 0 <= i < len(tasks)]

    def confirm_action(self, action: str) -> bool:
        """アクションの確認"""
        return Confirm.ask(f"{action}を実行しますか？", default=True)
```

##### CLIコマンド拡張

**修正ファイル**: `src/cmw/cli.py`

```python
@task.command('validate')
@click.option('--fix', is_flag=True, help='検出された問題を自動修正')
@click.option('--interactive', is_flag=True, help='対話的に修正')  # 🆕 追加
@click.option('--tasks-file', default='shared/coordination/tasks.json')
def validate_tasks(fix: bool, interactive: bool, tasks_file: str):
    """タスクの妥当性を検証"""
    from cmw.interactive_fixer import InteractiveFixer

    # ... 既存の検証処理 ...

    # 🆕 対話的修正
    if interactive and cycles:
        fixer = InteractiveFixer()
        tasks_list = fixer.fix_cycles_interactively(tasks_list, cycles)

        # 修正後のtasks.jsonを保存
        coordinator.save_tasks(tasks_list)
        console.print("[green]✅ 修正をtasks.jsonに保存しました[/green]")
    elif fix:
        # 既存の自動修正
        tasks_list = validator.auto_fix_cycles(tasks_list, cycles, auto_apply=True)
```

##### テストケース

**新規ファイル**: `tests/test_interactive_fixer.py`

```python
from unittest.mock import patch, MagicMock

def test_fix_cycles_interactively():
    """対話的修正テスト（モック使用）"""
    tasks = [
        Task(id="TASK-001", dependencies=["TASK-002"]),
        Task(id="TASK-002", dependencies=["TASK-001"]),
    ]
    cycles = [["TASK-001", "TASK-002"]]

    fixer = InteractiveFixer()

    # ユーザー入力をモック（選択肢1を選択）
    with patch('rich.prompt.Prompt.ask', return_value="1"):
        fixed_tasks = fixer.fix_cycles_interactively(tasks, cycles)

    # いずれかの依存が削除されている
    task_001 = next(t for t in fixed_tasks if t.id == "TASK-001")
    task_002 = next(t for t in fixed_tasks if t.id == "TASK-002")

    assert not ("TASK-002" in task_001.dependencies and
                "TASK-001" in task_002.dependencies)

def test_select_tasks_interactively():
    """タスク選択テスト"""
    tasks = [
        Task(id="TASK-001", title="認証"),
        Task(id="TASK-002", title="DB"),
    ]

    fixer = InteractiveFixer()

    with patch('rich.prompt.Prompt.ask', return_value="1"):
        selected = fixer.select_tasks_interactively(tasks)
        assert len(selected) == 1
        assert selected[0].id == "TASK-001"
```

##### 検証方法

```bash
# 対話的に修正
cmw task validate --interactive

# 期待される対話:
# ⚠️  2件の循環依存を検出しました
#
# 循環 1/2:
#   TASK-004 ↔ TASK-005
#
# ┏━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━┓
# ┃ 番号 ┃ 削除する依存        ┃ 理由            ┃ 信頼度  ┃
# ┡━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━┩
# │ 1   │ TASK-004 → TASK-005 │ モデル定義は... │ 85%    │
# │ 2   │ TASK-005 → TASK-004 │ ...            │ 60%    │
# └─────┴────────────────────┴────────────────┴────────┘
#
# どの修正案を適用しますか？ [1/2/s/c] (1):
```

**期待される結果**:
- ✅ ユーザーが修正案を選択できる
- ✅ 選択した修正が即座に適用される
- ✅ スキップ、キャンセルも可能
- ✅ 修正後のtasks.jsonが保存される

---

#### Phase 8.5: 応答解析の自動化 ⭐⭐⭐
**推定時間**: 3-4時間
**優先度**: 中

##### 実装内容

**新規ファイル**: `src/cmw/response_parser.py`

```python
"""
Response Parser - Claude Code出力の自動解析
"""
import re
from typing import List, Optional, Dict
from pathlib import Path

class ResponseParser:
    """Claude Codeの応答を解析してタスク完了を検出"""

    # ファイル作成/編集を示すパターン
    FILE_PATTERNS = [
        r'`([^`]+\.py)`\s*を作成',
        r'`([^`]+\.py)`\s*に.*を追加',
        r'`([^`]+\.py)`\s*を.*更新',
        r'`([^`]+\.py)`\s*を編集',
        r'Created\s+`([^`]+\.py)`',
        r'Updated\s+`([^`]+\.py)`',
        r'Modified\s+`([^`]+\.py)`',
    ]

    # タスク完了を示すキーワード
    COMPLETION_KEYWORDS = [
        '完了しました',
        '実装しました',
        '作成しました',
        '追加しました',
        'completed',
        'finished',
        'done',
    ]

    # タスクIDパターン
    TASK_ID_PATTERN = r'TASK-\d{3}'

    def __init__(self):
        self.file_regex = [re.compile(p, re.IGNORECASE) for p in self.FILE_PATTERNS]
        self.task_id_regex = re.compile(self.TASK_ID_PATTERN)

    def parse_response(self, response_text: str) -> Dict[str, any]:
        """
        Claude Codeの応答を解析

        Args:
            response_text: Claude Codeの出力テキスト

        Returns:
            解析結果の辞書
            {
                'artifacts': [...],  # 作成/編集されたファイル
                'task_ids': [...],   # 言及されたタスクID
                'is_completed': bool # 完了を示すキーワードがあるか
            }
        """
        artifacts = self._extract_artifacts(response_text)
        task_ids = self._extract_task_ids(response_text)
        is_completed = self._detect_completion(response_text)

        return {
            'artifacts': artifacts,
            'task_ids': task_ids,
            'is_completed': is_completed
        }

    def _extract_artifacts(self, text: str) -> List[str]:
        """応答からファイルパスを抽出"""
        artifacts = set()

        for regex in self.file_regex:
            matches = regex.findall(text)
            artifacts.update(matches)

        return sorted(artifacts)

    def _extract_task_ids(self, text: str) -> List[str]:
        """応答からタスクIDを抽出"""
        matches = self.task_id_regex.findall(text)
        return sorted(set(matches))

    def _detect_completion(self, text: str) -> bool:
        """完了キーワードを検出"""
        text_lower = text.lower()
        return any(kw in text_lower for kw in self.COMPLETION_KEYWORDS)

    def suggest_completion(self, response_text: str, task_id: str) -> Optional[str]:
        """
        タスク完了の提案を生成

        Args:
            response_text: Claude Codeの出力
            task_id: 対象タスクID

        Returns:
            完了コマンドの提案（完了していると判定されない場合はNone）
        """
        result = self.parse_response(response_text)

        if not result['is_completed']:
            return None

        if task_id not in result['task_ids'] and not result['artifacts']:
            return None

        if result['artifacts']:
            artifacts_str = json.dumps(result['artifacts'])
            return f"cmw.mark_completed('{task_id}', {artifacts_str})"
        else:
            return f"cmw.mark_completed('{task_id}', [])"

    def auto_mark_completed(self, response_text: str, task_id: str,
                           project_path: Path) -> bool:
        """
        応答からタスク完了を自動マーク

        Args:
            response_text: Claude Codeの出力
            task_id: 対象タスクID
            project_path: プロジェクトパス

        Returns:
            タスク完了をマークしたかどうか
        """
        from cmw.task_provider import TaskProvider

        result = self.parse_response(response_text)

        # 完了判定
        if not result['is_completed']:
            return False

        if task_id not in result['task_ids'] and not result['artifacts']:
            return False

        # タスク完了をマーク
        provider = TaskProvider(project_path)
        provider.mark_completed(task_id, result['artifacts'])

        return True
```

##### TaskProviderへの統合

**修正ファイル**: `src/cmw/task_provider.py`

```python
class TaskProvider:
    """既存クラスに追加"""

    def __init__(self, project_path: Path):
        self.project_path = project_path
        self.coordinator = Coordinator(project_path)
        self.template = PromptTemplate(project_path)
        self.response_parser = ResponseParser()  # 🆕 追加

    def parse_and_complete(self, task_id: str, response_text: str) -> bool:
        """
        応答を解析してタスク完了を自動マーク

        🆕 v0.3.0新機能

        Args:
            task_id: タスクID
            response_text: Claude Codeの出力

        Returns:
            タスク完了をマークしたかどうか
        """
        return self.response_parser.auto_mark_completed(
            response_text, task_id, self.project_path
        )

    def suggest_completion_command(self, task_id: str, response_text: str) -> Optional[str]:
        """
        完了コマンドの提案を取得

        🆕 v0.3.0新機能
        """
        return self.response_parser.suggest_completion(response_text, task_id)
```

##### CLIコマンド実装

**追加先**: `src/cmw/cli.py`

```python
@task.command('parse-response')
@click.argument('task_id')
@click.option('--response', type=click.Path(exists=True),
              help='Claude Codeの出力ファイル')
@click.option('--auto-complete', is_flag=True, help='自動的にタスク完了をマーク')
def parse_response(task_id: str, response: Optional[str], auto_complete: bool):
    """Claude Codeの応答を解析"""
    from rich.console import Console
    from cmw.task_provider import TaskProvider

    console = Console()
    provider = TaskProvider(Path.cwd())

    # 応答テキスト取得
    if response:
        with open(response, 'r', encoding='utf-8') as f:
            response_text = f.read()
    else:
        response_text = click.get_text_stream('stdin').read()

    # 解析
    result = provider.response_parser.parse_response(response_text)

    console.print("[bold]解析結果:[/bold]")
    console.print(f"成果物: {', '.join(result['artifacts']) or 'なし'}")
    console.print(f"タスクID: {', '.join(result['task_ids']) or 'なし'}")
    console.print(f"完了判定: {'✅ 完了' if result['is_completed'] else '⏳ 未完了'}")

    # 完了提案
    suggestion = provider.suggest_completion_command(task_id, response_text)
    if suggestion:
        console.print(f"\n[bold]完了コマンド提案:[/bold]")
        console.print(f"  {suggestion}")

        if auto_complete:
            success = provider.parse_and_complete(task_id, response_text)
            if success:
                console.print(f"\n[green]✅ {task_id} を完了にマークしました[/green]")
            else:
                console.print(f"\n[red]❌ タスク完了のマークに失敗しました[/red]")
```

##### テストケース

**新規ファイル**: `tests/test_response_parser.py`

```python
def test_parse_response():
    """応答解析テスト"""
    response = """
    TASK-001の認証機能を実装しました。

    `backend/auth.py` を作成し、以下の機能を追加しました:
    - JWT認証
    - パスワードハッシュ化

    `tests/test_auth.py` を作成し、テストを追加しました。
    """

    parser = ResponseParser()
    result = parser.parse_response(response)

    assert "backend/auth.py" in result['artifacts']
    assert "tests/test_auth.py" in result['artifacts']
    assert "TASK-001" in result['task_ids']
    assert result['is_completed'] is True

def test_suggest_completion():
    """完了提案テスト"""
    response = """
    `backend/auth.py` を作成しました。
    TASK-001を完了しました。
    """

    parser = ResponseParser()
    suggestion = parser.suggest_completion(response, "TASK-001")

    assert suggestion is not None
    assert "mark_completed" in suggestion
    assert "TASK-001" in suggestion
    assert "backend/auth.py" in suggestion

def test_auto_mark_completed(temp_project):
    """自動完了マークテスト"""
    response = """
    TASK-001の実装を完了しました。
    `backend/auth.py` を作成しました。
    """

    parser = ResponseParser()
    success = parser.auto_mark_completed(response, "TASK-001", temp_project)

    assert success is True
```

##### 検証方法

```bash
# 応答を解析（ファイルから）
echo "TASK-001を完了しました。\`backend/auth.py\`を作成しました。" > response.txt
cmw task parse-response TASK-001 --response response.txt

# 応答を解析（標準入力から）
echo "実装を完了しました" | cmw task parse-response TASK-001

# 自動的に完了をマーク
cmw task parse-response TASK-001 --response response.txt --auto-complete
```

**期待される結果**:
- ✅ ファイル作成/編集が検出される
- ✅ タスクIDが抽出される
- ✅ 完了キーワードが検出される
- ✅ 完了コマンドが提案される
- ✅ 自動的にタスク完了がマークされる

---

#### Phase 0.5: CLIコマンド名変更（tasks → task） ⭐⭐⭐⭐⭐
**推定時間**: 10-15分
**優先度**: 最高（v0.3.0の最初に実施）

##### 目的
業界標準（Git、Docker）に合わせて、CLIコマンド名を `cmw tasks` から `cmw task` に変更する。

##### 評価結果
- ✅ **業界標準に合致**: Git (`git branch`, `git tag`)、Docker (`docker container`, `docker image`) と同じ単数形パターン
- ✅ **より簡潔**: `tasks`（6文字）→ `task`（4文字）
- ✅ **より直感的**: 単数形の方が自然
- ✅ **実装コスト低**: 10-15分で完了
- ✅ **ベストタイミング**: v0.2.0リリース直後、ユーザーが少ない段階

##### 実装内容

**修正ファイル**: `src/cmw/cli.py`

```python
# 変更前
@cli.group()
def tasks():
    """タスク管理コマンド"""
    pass

# 変更後
@cli.group(name='task')
def task():
    """タスク管理コマンド"""
    pass

# 後方互換性のため tasks も残す（非推奨）
@cli.group(name='tasks', hidden=True)
def tasks_deprecated():
    """[非推奨] 'cmw task' を使用してください"""
    pass

# 共通のサブコマンドをセットアップ
def setup_task_commands(group):
    """タスクコマンドのサブコマンドをセットアップ"""

    @group.command('list')
    @click.option('--status', type=click.Choice(['pending', 'in_progress', 'completed', 'failed']))
    def list_tasks(status: Optional[str]):
        """タスク一覧を表示"""
        # 既存の実装

    @group.command('show')
    @click.argument('task_id')
    def show_task(task_id: str):
        """タスク詳細を表示"""
        # 既存の実装

    # ... その他のコマンド

# task と tasks_deprecated 両方にサブコマンドを追加
setup_task_commands(task)
setup_task_commands(tasks_deprecated)
```

##### ドキュメント更新

**更新ファイル**:
1. `README.md` - 全ての `cmw tasks` → `cmw task`
2. `V0.3.0_PLAN.md` - 全ての `cmw tasks` → `cmw task`
3. `docs/CLAUDE_CODE_INTEGRATION.md` - コマンド例の更新

##### テストケース更新

**修正ファイル**: `tests/test_cli*.py`

```python
# 変更前
result = runner.invoke(cli, ['tasks', 'list'])

# 変更後
result = runner.invoke(cli, ['task', 'list'])

# 後方互換性テスト追加
def test_tasks_deprecated():
    """非推奨コマンドのテスト"""
    runner = CliRunner()
    result = runner.invoke(cli, ['tasks', 'list'])

    # 動作することを確認（後方互換性）
    assert result.exit_code == 0
```

##### 検証方法

```bash
# 新コマンドの動作確認
cmw task list
cmw task show TASK-001
cmw task generate
cmw task validate

# 旧コマンドの動作確認（後方互換性）
cmw tasks list  # 動作する（非推奨）
```

**期待される結果**:
- ✅ `cmw task` コマンドが正常に動作
- ✅ `cmw tasks` コマンドも動作（後方互換性）
- ✅ ドキュメントが全て更新される
- ✅ テストが全てパス

---

## 📅 実装スケジュール

### Phase 0.5: CLIコマンド名変更（🆕追加）
- **Day 0** (10-15分): CLIコマンド名変更（`tasks` → `task`）

### Week 1: Phase 8.1-8.2（高優先度機能）
- **Day 1-2**: Phase 8.1 タスクグラフ可視化（2-3h）
- **Day 3-4**: Phase 8.2 プロンプトテンプレート（2-3h）
- **Day 5**: 統合テストとバグ修正

### Week 2: Phase 8.3-8.5（中優先度機能）
- **Day 6-7**: Phase 8.3 依存関係の静的分析（4-5h）
- **Day 8**: Phase 8.4 インタラクティブUI（2-3h）
- **Day 9-10**: Phase 8.5 応答解析の自動化（3-4h）

### Week 3: 統合テストとリリース
- **Day 11-12**: エンドツーエンドテスト
- **Day 13**: バグ修正
- **Day 14**: ドキュメント更新
- **Day 15**: v0.3.0 リリース

---

## 🧪 統合テストシナリオ

### シナリオ1: Blog API再検証（v0.3.0機能フル活用）

```bash
cd ~/workspace/projects/blog-api

# 1. タスクグラフを可視化
cmw task graph --show-critical-path --show-parallel-groups

# 2. 静的解析で依存関係を再推論
cmw task generate --analyze-imports

# 3. 対話的に問題を修正
cmw task validate --interactive

# 4. Claude Code統合テスト
python3 << 'EOF'
from cmw import TaskProvider
provider = TaskProvider(Path.cwd())

# プロンプト取得
prompt = provider.get_task_prompt("TASK-001")
print(prompt)

# Claude Codeがコーディング...
response = "TASK-001を完了しました。`backend/auth.py`を作成しました。"

# 自動完了
provider.parse_and_complete("TASK-001", response)
EOF
```

### シナリオ2: 新規プロジェクト作成

```bash
# 1. プロジェクト初期化
cmw init --name test-api

# 2. requirements.md作成
cat > shared/docs/requirements.md << 'EOF'
# Test API

## 1. 認証
- ユーザー登録
- ログイン

## 2. データ管理
- データ取得
- データ作成
EOF

# 3. タスク生成（静的解析付き）
cmw task generate --analyze-imports

# 4. グラフ可視化
cmw task graph

# 5. 検証
cmw task validate

# 期待: 全チェックPASS
```

### シナリオ3: Claude Code統合フロー

```
ユーザー: 「test-apiの次のタスクを実行して」

Claude Code:
1. プロンプト取得
   provider = TaskProvider(Path.cwd())
   prompt = provider.get_task_prompt("TASK-001")

2. プロンプトを確認
   print(prompt)
   # → タスク概要、実装内容、受け入れ基準が表示

3. コーディング（自分で実行）
   # backend/auth.py を作成...

4. 応答を解析
   response = "TASK-001を完了しました。`backend/auth.py`を作成しました。"
   provider.parse_and_complete("TASK-001", response)
   # → 自動的にタスク完了がマーク

5. 次のタスクを取得
   next_task = provider.get_next_task()
   # → TASK-002が返る
```

---

## 📊 期待される効果

### Before (v0.2.0)
```
- タスク依存関係が分かりにくい
- Claude Codeへのプロンプトが最適化されていない
- Python依存関係が手動推論のみ
- 問題修正が非対話的
- タスク完了が手動報告
```

### After (v0.3.0)
```
✅ タスクグラフで依存関係を一目で理解
✅ 最適化されたプロンプトでClaude Code統合改善
✅ Python依存関係が自動解析
✅ 対話的に問題を修正可能
✅ Claude Code出力から自動的にタスク完了を検出
```

### 改善率
- **タスク可視化**: なし → あり（新機能）
- **プロンプト最適化**: 基本 → 最適化済み（+50%効率化）
- **依存関係推論精度**: 60% → 85%（+25%向上）
- **UX満足度**: 予測 +40%向上
- **手動作業削減**: -30%削減（自動完了検出）

---

## 🎯 v0.4.0以降の計画（参考）

v0.3.0完了後に検討する機能：

1. **ファイル競合検出の精度向上（関数レベル）** - 4-5時間
   - AST解析で関数レベルの競合を検出
   - 同じファイルでも異なる関数なら並列実行可能

2. **タスク説明の簡潔化** - 1時間
   - 長い説明を自動要約
   - キーワード抽出

3. **MCP統合（Phase 2.4）** - 2-3日
   - Model Context Protocol統合
   - Claude Code Desktopとの緊密な統合
   - リアルタイム双方向通信

4. **タスクテンプレート機能** - 2-3時間
   - よく使うタスクパターンをテンプレート化
   - `cmw task create --template crud`

5. **Git統合の強化** - 2-3時間
   - 自動コミット・プッシュ
   - ブランチ戦略の自動化

---

## 📝 成功基準（v0.3.0）

### 機能要件
- ✅ タスクグラフが3種類の形式（ASCII、Mermaid、PNG）で出力可能
- ✅ プロンプトテンプレートが使用可能
- ✅ Python依存関係が自動解析される
- ✅ 循環依存が対話的に修正可能
- ✅ Claude Code出力からタスク完了が自動検出される

### 品質要件
- ✅ 全ての新機能にユニットテストがある（カバレッジ80%以上）
- ✅ 既存のテストが全てパス（153個 → 180個以上）
- ✅ blog-apiとtodo-apiで動作確認完了
- ✅ ドキュメントが更新されている

### パフォーマンス要件
- ✅ タスクグラフ生成が1秒以内（100タスク）
- ✅ 静的解析が5秒以内（50ファイル）
- ✅ 応答解析が0.5秒以内

---

## 🔗 関連ドキュメント

- **v0.2.0リリースノート**: README.md
- **Phase 1-7実装詳細**: docs/planning/multiworker-framework-plan-v3.md
- **改善計画**: IMPROVEMENT_PLAN.md
- **Claude Code統合ガイド**: docs/CLAUDE_CODE_INTEGRATION.md

---

**策定日**: 2025-10-16
**策定者**: Claude Code
**次のアクション**: Phase 8.1（タスクグラフ可視化）の実装開始
