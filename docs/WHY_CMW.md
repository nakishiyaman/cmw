# なぜcmwが必要なのか？

**作成日**: 2025-10-17
**対象読者**: Claude Codeユーザー、大規模プロジェクト開発者

---

## 🎯 結論: Claude Codeだけでは不十分

Claude Codeは強力なコード生成ツールですが、**大規模プロジェクトでは限界**があります。

cmwは**タスク管理・メタデータ層**として、Claude Codeを補完し、30タスク以上の大規模プロジェクトを効率的に管理します。

---

## 🤔 Claude Code単体の3つの限界

### 問題1: セッションを跨ぐと文脈が消える

**Claude Code単体**:
```
セッション1（月曜日）:
あなた: "ToDoアプリを作って、タスク1-10完了"
Claude Code: "了解！実装しました"

...3日後...

セッション2（木曜日）:
あなた: "続きをお願い"
Claude Code: "どこまで完了しましたか？何を実装しましたか？"
あなた: "えっと...タスク1-10は完了で、タスク11から..."
           ↑ 毎回説明が必要、時間の無駄
```

**cmw併用**:
```
セッション2（木曜日）:
あなた: "続きをお願い"
cmw status  # → 即座に進捗を表示
# プロジェクト全体: 58.8%完了
# 完了: 10タスク、残り: 7タスク
# 次のタスク: TASK-011 - タスクの優先度変更

Claude Code: "了解！TASK-011から始めます"
           ↑ 文脈の再説明不要、即座に作業開始
```

**結論**: progress.jsonで状態を永続化し、**数週間後でも即座に再開可能**

---

### 問題2: 依存関係の追跡が手動で、ミスが発生

**Claude Code単体**:
```
あなた: "タスクAを実装して"
Claude Code: "タスクAはタスクBに依存してますよね？"
あなた: "いや、タスクCにも依存してます"
Claude Code: "了解！...あれ、循環依存してませんか？"
あなた: "えっと...確認します...（30分後）...してました"
           ↑ 手動追跡で時間がかかる、ミスも多い
```

**cmw併用**:
```
cmw tasks generate  # → requirements.mdから自動でタスク生成
cmw tasks validate --fix  # → 循環依存を自動検出・修正

# ✅ 循環依存を検出: TASK-005 → TASK-002 → TASK-005
# 🔧 自動修正: TASK-005の依存をTASK-001に変更
# ✅ 17タスク、依存関係23個、循環なし

cmw task graph  # → 依存関係グラフを可視化
# TASK-001 → TASK-002 → TASK-005
#          ↘ TASK-003 ↗
#          ↘ TASK-004 ↗

あなた: "依存関係は完璧！実装開始"
           ↑ NetworkXで自動管理、ミスゼロ
```

**結論**: NetworkXベースの自動管理で、**依存関係の追跡が完全自動化**

---

### 問題3: ファイル競合の事前検出不可

**Claude Code単体**:
```
あなた: "タスク1とタスク2を並行して実装して"

Claude Code: "タスク1を実装しました（auth.pyを編集）"
Claude Code: "タスク2を実装しました（auth.pyを編集）"
           ↑ 同じファイルを編集！

あなた: "あれ、auth.pyが競合してる...どっちが正しい？"
           ↑ 実行してみないと競合に気づかない
```

**cmw併用**:
```
cmw tasks analyze  # → ファイル競合を事前検出

# ⚠️  CRITICAL: auth.py に2タスクが同時書き込み
#    - TASK-001: ユーザー登録（auth.py）
#    - TASK-002: ログイン（auth.py）
#
# 推奨実行順序: TASK-001 → TASK-002
# 並列実行グループ: [TASK-003, TASK-004] → [TASK-001] → [TASK-002]

あなた: "TASK-001から順番に実装しよう"
           ↑ 事前に競合を検出、実行順序を提案
```

**結論**: トポロジカルソートで**実行順序を自動提案**、競合を回避

---

## 📊 比較表: Claude Code単体 vs cmw併用

| シチュエーション | Claude Code単体 | cmw併用 |
|---------------|----------------|---------|
| **プロジェクト規模** | 10タスク以下 | 30タスク以上 |
| **開発期間** | 1日で完了 | 複数日〜数週間 |
| **セッション管理** | 毎回文脈を再説明 | progress.jsonで自動継続 |
| **依存関係管理** | 手動で追跡（ミス多発） | NetworkXで自動管理、循環検出 |
| **ファイル競合** | 実行してみないと分からない | 事前に検出、実行順序を提案 |
| **チーム開発** | 進捗共有が困難 | Git + cmw syncで同期 |
| **タスク分解** | 毎回手動で依頼 | requirements.md → 自動生成 |
| **進捗可視化** | テキストのみ | Richで美しいダッシュボード |

---

## ✅ cmwを使うべきケース

### 1. 30タスク以上の大規模プロジェクト
- 例: blog-api（15タスク）、todo-api（17タスク）、e-commerce（50タスク）
- 理由: タスク数が増えると手動管理が困難に

### 2. 複数セッションにまたがる開発
- 例: 1週間〜1ヶ月かかるプロジェクト
- 理由: セッションを跨ぐと文脈が消える

### 3. 複雑な依存関係（10+の依存リンク）
- 例: バックエンド（DB、認証、API）→ フロントエンド（UI、状態管理）
- 理由: 手動追跡でミスが発生

### 4. チーム開発で進捗を共有したい
- 例: 3人チームで並行開発
- 理由: Git + cmw syncで進捗を自動同期

### 5. ファイル競合を事前に検出したい
- 例: 複数タスクが同じファイルを編集
- 理由: 実行前に競合を検出、実行順序を提案

---

## ❌ cmwを使わなくていいケース

### 1. 10タスク以下の小規模プロジェクト
- 例: 簡単なスクリプト、ユーティリティ
- 理由: Claude Code単体で十分管理可能

### 2. 1日で完了するシンプルな開発
- 例: バグ修正、機能追加
- 理由: セッションを跨がない

### 3. 単純な1ファイル修正
- 例: README更新、設定ファイル修正
- 理由: タスク管理が不要

### 4. 依存関係がない独立したタスク
- 例: テストの追加、ドキュメント作成
- 理由: 依存関係管理が不要

---

## 🤝 cmwとClaude Codeの役割分担

### アーキテクチャ

```
あなた「ToDoアプリを作って」
  ↓
┌─────────────────────────────────────────┐
│ Claude Code（司令塔 + 実行層）          │
│  - 自然言語理解                          │
│  - コード生成（自身の機能）              │
│  - ファイル操作                          │
│  - テスト実行                            │
│  - エラー検出と修正                      │
└─────────────────────────────────────────┘
  ↓ ↑ タスク情報の取得・完了報告
┌─────────────────────────────────────────┐
│ cmw（タスク管理・メタデータ層）         │
│  - requirements.md → タスク分解         │
│  - 依存関係グラフ管理                   │
│  - 進捗状態の永続化                     │
│  - ファイル配置ルール                   │
│  - 受け入れ基準                         │
│  - ファイル競合検出                     │
└─────────────────────────────────────────┘
```

### 役割分担

**cmwが担当（WHAT/WHEN/WHERE）:**
- **WHAT**: 何を実装するか（タスク定義）
- **WHEN**: いつ実装するか（依存関係、優先度）
- **WHERE**: どこに実装するか（ファイル配置）

**Claude Codeが担当（HOW/WHY）:**
- **HOW**: どう実装するか（技術スタック、実装パターン）
- **WHY**: なぜそう実装するか（設計判断、最適化）

---

## 💡 具体例: todo-apiの開発

### Claude Code単体の場合（推定: 10時間）

```
1. 要件定義を説明（30分）
あなた: "ToDoアプリを作って。ユーザー認証、ToDoのCRUD、..."
Claude Code: "了解！まずはデータベース設計から..."

2. タスク分解を依頼（30分）
あなた: "タスクに分解して"
Claude Code: "17タスクに分解しました"
あなた: "依存関係は？"
Claude Code: "タスク2はタスク1に依存..."
あなた: "循環依存してない？"
Claude Code: "確認します...してました、修正します"

3. タスク実行（7時間）
あなた: "タスク1を実装して"
Claude Code: "実装しました"
あなた: "タスク2を実装して"
Claude Code: "タスク1の情報を教えてください"
あなた: "タスク1はbackend/auth.pyで..."
           ↑ 毎回文脈を説明

4. セッション再開（3日後、1時間）
あなた: "続きをお願い"
Claude Code: "どこまで完了しましたか？"
あなた: "タスク1-10は完了で..."
           ↑ 進捗を説明

5. 競合発見（1時間）
あなた: "タスク11とタスク12を実装して"
Claude Code: "実装しました"
あなた: "あれ、同じファイルを編集してる..."
           ↑ 競合が発生、手動で修正

**合計: 約10時間**
```

### cmw併用の場合（推定: 5時間）

```
1. 要件定義（30分）
requirements.mdを作成

2. タスク生成（5分）
cmw tasks generate  # → 17タスクを自動生成
cmw tasks validate --fix  # → 循環依存を自動修正
cmw tasks analyze  # → ファイル競合を事前検出

3. タスク実行（3.5時間）
from cmw import TaskProvider
provider = TaskProvider(Path.cwd())

while True:
    task = provider.get_next_task()
    if not task:
        break

    # Claude Codeがコード生成
    # ...

    provider.mark_completed(task.id, artifacts=["backend/auth.py"])

4. セッション再開（3日後、30分）
cmw status  # → 即座に進捗を表示
task = provider.get_next_task()  # → 次のタスクを取得
# 文脈の説明不要、即座に作業開始

5. 競合は事前に検出済み
cmw tasks analyze  # → ファイル競合を事前に検出
# 推奨実行順序に従って実装

**合計: 約5時間（50%削減）**
```

---

## 📈 実績: todo-apiでの効果

### プロジェクト概要
- **規模**: 17タスク、2000行コード、106テスト
- **期間**: 2日（cmw併用）
- **成果**: 全タスク完了、全テストパス、9つのAPIエンドポイントが正常動作

### cmwの効果
- **タスク生成**: 手動17タスク → 自動20タスク（3タスク追加検出）
- **循環依存**: 自動検出・修正（手動では見落としていた）
- **ファイル競合**: 2件検出（CRITICAL 1件、MEDIUM 1件）
- **進捗管理**: progress.jsonで自動追跡、セッション再開が即座
- **所要時間**: 推定10時間 → 実際5時間（50%削減）

### ユーザーの声（検証後）
> 「requirements.mdを書くだけで、タスク分解・依存関係・ファイル配置が全自動。
> Claude Codeとの連携も完璧で、大規模プロジェクトには必須のツール」

---

## 🚀 まとめ: cmwの独自価値

### 1. 永続的なメタデータ層
- **Claude Code**: セッション終了で記憶消失
- **cmw**: progress.json、tasks.jsonで状態永続化
- **効果**: 数週間かかる大規模プロジェクトで決定的な差

### 2. 構造化された依存関係管理
- **Claude Code**: 毎回手動説明が必要
- **cmw**: NetworkXベースのグラフアルゴリズム、自動判定
- **効果**: 循環依存を自動検出・修正、並列実行可能性を自動判定

### 3. ファイル競合の事前検出
- **Claude Code**: 実行してみないと分からない
- **cmw**: 実行前に問題を発見、実行順序を提案
- **効果**: 競合によるロールバックを回避

### 4. requirements.md → タスク自動生成
- **Claude Code**: 「タスク分解してください」と毎回依頼が必要
- **cmw**: 一度書けば自動化
- **効果**: 手動17タスク → 自動20タスク（見落としを検出）

---

## 🎯 結論

**「Claude Codeで全部できる」は、「メモ帳でコード書ける」と同じ論理です。**

できるけど、**効率が全然違う**。

**cmwは「Claude Code用のプロジェクト管理IDE」です。**

- 10タスク以下の小規模プロジェクト → Claude Code単体
- 30タスク以上の大規模プロジェクト → cmw併用

**価値があるし、求めている人は確実にいます。**

---

## 📚 関連ドキュメント

- [README.md](../README.md) - プロジェクト概要
- [Claude Code統合ガイド](CLAUDE_CODE_INTEGRATION.md) - 統合方法
- [インストール手順](../README.md#インストール) - インストール方法
- [クイックスタート](../README.md#クイックスタート) - 5分で始める

---

**最終更新**: 2025-10-17
**バージョン**: v0.3.1
**作成者**: nakishiyaman
